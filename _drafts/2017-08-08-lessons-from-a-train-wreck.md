---
layout: post
title: "Lessons from a failed project"
tags:
    
---
At the end of 2016, I was involved in a train-wreck project. This was an enhancement to a functioning application. The functionality was proven, they just needed to automate some parts. There I used the magic word "just". A few wish list items quickly turns into a large backlog, but that wasn't the problem. One of the key problems is taking a human decision and turning it into a computer's algorithm. People can entertain much fuzzier logic than a computer and some flexible programming was required. And still, that wasn't the problem. Let me explain. 

I have been maintaining this application for some time and I had got over the bump that is a natural part of learning a new system. Once you know most of the surprises and ins-and-outs, things start getting easier, and you start making better decisions and being more productive. However the functionality was about 40-50 days of work for a senior developer, so one of the consultants was to undertake the project. And they seemed to be doing a fine job in terms of backlog management and completing stories... Until a few days from the deadline. The deadline wasn't a launch deadline, but the number of days allocated to the work was running out. We had identified some new scope, but so it went a bit longer but was still nowhere near finished. And worse, it was riddled with bugs and the same issues kept happening again and again. In fact by this point, a second developer had been added. I know, everybody knows adding people just makes things take longer but he was added early on enough that it should have worked. 

Reports from the client was there was a communication problem. Reports from the developers was that they didn't like the other developer, and the technology was shit. I was asked to help out by managing the communication. Since I had an established rapport with the client, and was used to how they work, the idea was I could smooth over the communication problems, replace the first developer, re-estimate the project and get it back on track. 

So we estimated it to be another good couple of weeks. I identified what was remaining to be done, what bugs were raised and what if anything was out of scope which turned out not to be too much, although the original scope was a bit vague due to some ambiguous wording. 

I spoke with the developer, but couldn't identify any areas to improve. All my ideas had already been thought of. They had ditched a bunch of functional tests, because the test framework was too complex. I asked if was an idea to fix this, but no they had tried and it wasn't worth it. I asked if we needed to refactor the complex parts of the code which were causing bugs but no, they didn't have time to do that and it would just create more problems. I said we should do code reviews, so that I could have some input into the code being produced even though I didn't have capacity for the project, but the developer got impatient and started skipping these steps. 

It wasn't until nearly the next deadline that I happened to be reviewing some code, and I realised that some entity framework database migrations weren't working because two competing branches had been added together. You can't do this with EF migrations, because the migrations takes a snapshot of the database at the time the migration is created, and uses that snapshot to ensure it is running on the right version of the database schema. Talking this over with the developer and he said "oh... That explains it" and I realised he had probably been doing this frequently over the course of the project. 

I will call this my first mistake. I didn't realise that the developer was struggling technically with the project, even though in retrospect all the signs were there: not writing tests, not refactoring, not doing code review and finally not being able to manage database migrations. I realised there weren't just communication problems, there were code quality problems. I wish I had tried a little harder to understand the frustrations of the developer I was meant to help. Had I dug a little deeper I might have discovered I could have help far earlier. I was too quick to believe that he was at least as competent a developer as me if not better. In the future I will take more care of the technical side of things even if somebody suggests the problems are all down to soft skills. 

So now we have missed the next deadline as well. We did deliver some things, but certain parts of the application are still giving us more and more bugs. We have actually added technical debt to the project rather than removing it, and it had plenty to start. I actually discovered a code comment at the top of one of the controller which said something to the effect of // this code is a constant source of bugs. It needs refactoring. It will be painful but it has to be done. 

Well it still wasn't done. I asked some colleagues who were involved with the project during it's initial development phase and they actually recalled that there were several attempts to fix this bad code but it just couldn't be done. I realised this project was always going to be tough. 

Despite some very bad code, we had delivered a lot of functionality and squashed several persistent bugs, but there was still a problem. I began to notice the clients using certain words a lot to convey something which wasn't literally in the system. They had several "rules" as they called them. Each rule was a single logical statement about the state of the system, but the behaviour of the system when this rule held and when it was broken was extremely different for each rule in question. Sometimes they needed it to change a record, sometimes it need to send and email and sometimes it just needed to display a warning, or a combination of the above. Also, some rules were conditional on other rules. This wasn't captured in so many words anywhere in the documentation or backlog stories, and it certainly wasn't represented in the code. All we had was a bunch of if statements floating around in different classes. Sometimes a list of strings would be constructed based on a handful of these conditions, and then later parts of the code would need to infer from the contents of that list what it needed to do. In the end, it there wasn't any possible way to get the app to work as desired using this implementation. 

I used this as an opportunity. I explained to the client that we needed to document all the different rules and the outcomes when they were broken, so that I could make the code more flexible. I advised that we stop development until the documentation was nearly complete (thinking to myself it might not even be possible to complete), and then we could make a decision on what to do next. This was an extremely useful plan, despite it not really being much of a plan at all, because by now I was being asked questions by the sales, my manager and my manager's manager and the even some sideways managers of what went wrong, whose fault it was and what we were going to do to fix it. 

At this stage we had already given a lot of free work to the client in terms of days, because we believed the work we had completed wasn't up to our high standard. The reason for that was mainly around project management. We hadn't escalated the problems to the right people, and hadn't identified and removed barriers in our way, which amounted to getting all the way up to the last day and saying "whoops, this still isn't done." This wasn't entirely just our fault, the client wasn't entirely in the dark and did nothing. 

Anyway even though I had a plan, I did admit to the managers that the code was not good. This lead to them promising more free work, and I was getting a bit upset. My managers wanted to deliver this project no matter what. This client has always created stressful environments for the devs to work it. Almost all of the developers involved in the original project have since left, which we wonder if it wasn't because they figured if this is how projects go, why stay? So I was seriously wondering why we didn't just tell the client to take it or leave it. It's win-win for us because if they agreed to pay out the remainder, it's business as usual for us. If they said no, we could just never work with them again. Problem solved. So I asked my manager why. Isn't this just the sunk cost fallacy? 

The answer was a good one, lesson number 2. Yes we could just drop it, but it doesn't stop there. We would burn the bridge with that client, and when they next engaged a consultancy they might discuss this with them, which would damage our reputation. We have a great reputation, which is more important in the long run than losing some money on a project. And ultimately it means that we deliver what we say we will deliver, and that we're prepared to make things work, and own up to mistakes we make. 

Another reason I was worried was for my own career. What did I have to gain by this? At best, I manage to finish the project way overtime and without of lot of the functionality from the original scope. At worst, my estimates and my plan all fail miserably and I am remembered was someone you don't want to come and try and save your project, since I just blame the developers and then proceed to do just as bad a job. 

I am glad I had the courage to relate this to my manager, because they did exactly the right thing and told me that nobody would blame me, that they would understand it is difficult and there were issues in the code to begin with. I was still stressed as hell but I was content to do the work. 

Working on the documentation with the client turned out to be a great opportunity. The key stakeholder was known to be difficult and would often send emails which made people feel angry or insulted. I had a already worked with them to analyse the scope creep, and I had realised that despite being blunt in emails, they were someone who could be relied on to stop small errors and to respond to things quickly and with precision. This turned out to be extremely useful when documenting the various rules, which needed to be very exact. The client did at least half the work on the document, and it had approximately 15 revisions, and the list of rules grew from about 15 to 30. By the time work was ready to start again, I had added 30 or so new items to the backlog and had all but written the code, knowing exactly how I would implement each rule now that I was so familiar with them. I split the code into legacy and new implementation, so that any of the rules which did actually already work could still be put into production without re-write. So lesson number 3 is collaborate with your clients. 

Another key moment in the project came shortly before starting work on the new rules engine. My manager joined me in after I sent a status update that said we had made no progress at all for three or so days. I had recently finished scrum training, and I knew that any backlog item that was not complete must be added to the next sprint. I also new that unless an item is DONE then it is not complete. Since the definition of done includes passing all tests, and there were still issues, nothing was getting done. But in reality, progress was being made, as I was uncovering more and more bugs, I was fixing more and more issues as we went. Under the guidance of my manager, it was insisted that any backlog item that was in UAT that had a defect STAY in UAT and a bug added to the backlog, rather than the item going into the next sprint in the committed work. To me, this seems like 6 of one and half a dozen of the other, but it turned out to make my clients much happier. By tracking every defect separately, they could see dozens of bugs going into the done column, and they could also see I was fixing them just as fast as they were being discovered. It also allowed me to differentiate between two technically different bugs which lead to the same test result, which helped with the idea that I was actually fixing something rather than fixing one thing and breaking something else. I don't know if this is as per scrum, but it doesn't go against any principles as long as you don't mark something DONE when it isn't, so I will do this always. I still don't believe in purely "technical" items but that's another story. Lesson number 4 is just create more bugs. 

And those are all my lessons. Suddenly there weren't very many items in the backlog anymore, and I began seeing emails saying "thankyou" and "we did it." 

I don't want to get into specifics, but I had some dark times on this project. At one point I was so stressed out, angry and confused I began to fantasize about quitting my job. I didn't want to quit, and I didn't even plan to quit, I just started fantasizing about it, imaging how good I would feel if I just said enough is enough and walked out the door, maybe getting a job in an in-house development team where I could build a team and really make a difference. I knew I wouldn't, but I also didn't know how I was going to get through this. Consider this a lesson as yet unlearned, since I still take things more seriously than I need to. If I had known the future, maybe I could have just stayed calm and worked through it. 

I hope at least some of these lessons help somebody. 
